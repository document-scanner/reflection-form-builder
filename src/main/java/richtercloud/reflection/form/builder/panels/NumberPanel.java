/**
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package richtercloud.reflection.form.builder.panels;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Group;
import javax.swing.JCheckBox;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.LayoutStyle;
import javax.swing.SpinnerNumberModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

/**
 * A component to generate ids for entity instances. Ids are only generated for
 * valid instances (i.e. after validation with Java Validation API). This
 * restriction isn't necessary, but generation of intermediate ids on invalid
 * instances doesn't make sense.
 *
 * @author richter
 * @param <N> the type of {@link Number}s to manage
 */
/*
internal implementation notes:
- There's no sense in providing a generic id panel for numeric ids because
type of SpinnerNumberModel is determined at initialization.
- There's no sense to specify a type of NumberPanelUpdateListener because it
can't be initialized
- Since horizontal and vertical group of layout need to be exposed in order to
allow adding components in subclasses this class can't be designed in the
NetBeans GUI builder because it shouldn't influence the programming style
- in order to avoid intialValue overwriting the value represented by components
and because it doesn't have a disadvantage there's no simple getter for the
value property by a retrieval method retrieveValue which evaluates component
state -> value isn't changed after component update (only the UI state)
*/
public abstract class NumberPanel<N extends Number> extends JPanel {
    private static final long serialVersionUID = 1L;
    private final SpinnerNumberModel idSpinnerModel = new SpinnerNumberModel((Long)0L, (Long)0L, (Long)Long.MAX_VALUE, (Long)1L); //the cast to Long is necessary otherwise Doubles are retrieved from component later
    private Set<NumberPanelUpdateListener<N>> updateListeners = new HashSet<>();
    private Group layoutHorizontalGroup;
    private Group layoutVerticalGroup;
    private JSpinner valueSpinner;
    private JCheckBox nullCheckBox;
    private final Number initialValue;

    public NumberPanel(N initialValue) {
        initComponents();
        this.valueSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                for(NumberPanelUpdateListener<N> updateListener : NumberPanel.this.updateListeners) {
                    updateListener.onUpdate(new NumberPanelUpdateEvent<>(retrieveValue()));
                }
            }
        });
        this.initialValue = initialValue;
        reset();
    }

    public JSpinner getValueSpinner() {
        return valueSpinner;
    }

    public void addUpdateListener(NumberPanelUpdateListener<N> updateListener) {
        this.updateListeners.add(updateListener);
    }

    public void removeUpdateListener(NumberPanelUpdateListener<N> updateListener) {
        this.updateListeners.remove(updateListener);
    }

    public Set<NumberPanelUpdateListener<N>> getUpdateListeners() {
        return Collections.unmodifiableSet(updateListeners);
    }

    public N retrieveValue() {
        return (N) (getNullCheckBox().isSelected() ? null : getValueSpinner().getValue());
    }

    public JCheckBox getNullCheckBox() {
        return nullCheckBox;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    private void initComponents() {

        valueSpinner = new JSpinner();
        nullCheckBox = new JCheckBox();

        valueSpinner.setModel(this.idSpinnerModel);

        nullCheckBox.setText("null");
        nullCheckBox.addActionListener(new java.awt.event.ActionListener() {
            @Override
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nullCheckBoxActionPerformed(evt);
            }
        });

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        this.layoutHorizontalGroup = layout.createParallelGroup(GroupLayout.Alignment.LEADING);
        this.layoutVerticalGroup = layout.createParallelGroup(GroupLayout.Alignment.LEADING);
        layout.setHorizontalGroup(this.layoutHorizontalGroup
            .addGroup(layout.createSequentialGroup()
                .addComponent(nullCheckBox)
                .addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(valueSpinner, GroupLayout.DEFAULT_SIZE, 397, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(this.layoutVerticalGroup
            .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                .addComponent(valueSpinner, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                .addComponent(nullCheckBox))
        );
    }

    protected Group getLayoutHorizontalGroup() {
        return layoutHorizontalGroup;
    }

    protected Group getLayoutVerticalGroup() {
        return layoutVerticalGroup;
    }

    @Override
    public GroupLayout getLayout() {
        return (GroupLayout) super.getLayout();
    }

    private void nullCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {
        if(nullCheckBox.isSelected()) {
            this.valueSpinner.setEnabled(false);
        }else {
            this.valueSpinner.setEnabled(true);
        }
        for(NumberPanelUpdateListener<N> updateListener : this.updateListeners) {
            updateListener.onUpdate(new NumberPanelUpdateEvent<>(retrieveValue()));
        }
    }

    public void reset() {
        if(initialValue == null) {
            this.nullCheckBox.setSelected(true);
            this.valueSpinner.setEnabled(false);
        }else {
            this.valueSpinner.setValue(initialValue);
            this.nullCheckBox.setSelected(false); //might not be necessary, but is clearer
        }
    }
}
